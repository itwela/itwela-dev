"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const e={attribute:/\[\s*(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)\s*(?:(?<operator>\W?=)\s*(?<value>.+?)\s*(\s(?<caseSensitive>[iIsS]))?\s*)?\]/gu,id:/#(?<name>[-\w\P{ASCII}]+)/gu,class:/\.(?<name>[-\w\P{ASCII}]+)/gu,comma:/\s*,\s*/g,combinator:/\s*[\s>+~]\s*/g,"pseudo-element":/::(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>¶*)\))?/gu,"pseudo-class":/:(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>¶*)\))?/gu,universal:/(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?\*/gu,type:/(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)/gu},t=new Set(["combinator","comma"]),n=new Set(["not","is","where","has","matches","-moz-any","-webkit-any","nth-child","nth-last-child"]),s=/(?<index>[\dn+-]+)\s+of\s+(?<subtree>.+)/,o={"nth-child":s,"nth-last-child":s},r=t=>{switch(t){case"pseudo-element":case"pseudo-class":return new RegExp(e[t].source.replace("(?<argument>¶*)","(?<argument>.*)"),"gu");default:return e[t]}};function c(e,t){let n=0,s="";for(;t<e.length;t++){const o=e[t];switch(o){case"(":++n;break;case")":--n}if(s+=o,0===n)return s}return s}function i(n,s=e){if(!n)return[];const o=[n];for(const[e,t]of Object.entries(s))for(let n=0;n<o.length;n++){const s=o[n];if("string"!=typeof s)continue;t.lastIndex=0;const r=t.exec(s);if(!r)continue;const c=r.index-1,i=[],a=r[0],l=s.slice(0,c+1);l&&i.push(l),i.push({...r.groups,type:e,content:a});const u=s.slice(c+a.length+1);u&&i.push(u),o.splice(n,1,...i)}let r=0;for(const e of o)switch(typeof e){case"string":throw new Error(`Unexpected sequence ${e} found at index ${r}`);case"object":r+=e.content.length,e.pos=[r-e.content.length,r],t.has(e.type)&&(e.content=e.content.trim()||" ")}return o}const a=/(['"])([^\\\n]+?)\1/g,l=/\\./g;function u(t,n=e){if(""===(t=t.trim()))return[];const s=[];t=(t=t.replace(l,((e,t)=>(s.push({value:e,offset:t}),"".repeat(e.length))))).replace(a,((e,t,n,o)=>(s.push({value:e,offset:o}),`${t}${"".repeat(n.length)}${t}`)));{let e,n=0;for(;(e=t.indexOf("(",n))>-1;){const o=c(t,e);s.push({value:o,offset:e}),t=`${t.substring(0,e)}(${"¶".repeat(o.length-2)})${t.substring(e+o.length)}`,n=e+o.length}}const o=i(t,n),u=new Set;for(const e of s.reverse())for(const t of o){const{offset:n,value:s}=e;if(!(t.pos[0]<=n&&n+s.length<=t.pos[1]))continue;const{content:o}=t,r=n-t.pos[0];t.content=o.slice(0,r)+s+o.slice(r+s.length),t.content!==o&&u.add(t)}for(const e of u){const t=r(e.type);if(!t)throw new Error(`Unknown token type: ${e.type}`);t.lastIndex=0;const n=t.exec(e.content);if(!n)throw new Error(`Unable to parse content for ${e.type}: ${e.content}`);Object.assign(e,n.groups)}return o}function p(e,{list:t=!0}={}){if(t&&e.find((e=>"comma"===e.type))){const t=[],n=[];for(let s=0;s<e.length;s++)if("comma"===e[s].type){if(0===n.length)throw new Error("Incorrect comma at "+s);t.push(p(n,{list:!1})),n.length=0}else n.push(e[s]);if(0===n.length)throw new Error("Trailing comma");return t.push(p(n,{list:!1})),{type:"list",list:t}}for(let t=e.length-1;t>=0;t--){let n=e[t];if("combinator"===n.type){let s=e.slice(0,t),o=e.slice(t+1);return{type:"complex",combinator:n.content,left:p(s),right:p(o)}}}switch(e.length){case 0:throw new Error("Could not build AST.");case 1:return e[0];default:return{type:"compound",list:[...e]}}}function*f(e,t){switch(e.type){case"list":for(let t of e.list)yield*f(t,e);break;case"complex":yield*f(e.left,e),yield*f(e.right,e);break;case"compound":yield*e.list.map((t=>[t,e]));break;default:yield[e,t]}}function h(e,{recursive:t=!0,list:s=!0}={}){const r=u(e);if(!r)return;const c=p(r,{list:s});if(!t)return c;for(const[e]of f(c)){if("pseudo-class"!==e.type||!e.argument)continue;if(!n.has(e.name))continue;let t=e.argument;const s=o[e.name];if(s){const n=s.exec(t);if(!n)continue;Object.assign(e,n.groups),t=n.groups.subtree}t&&Object.assign(e,{subtree:h(t,{recursive:!0,list:!0})})}return c}function m(e,t){return t=t||Math.max(...e)+1,e[0]*(t<<1)+e[1]*t+e[2]}exports.RECURSIVE_PSEUDO_CLASSES=n,exports.RECURSIVE_PSEUDO_CLASSES_ARGS=o,exports.TOKENS=e,exports.TRIM_TOKENS=t,exports.flatten=f,exports.gobbleParens=c,exports.parse=h,exports.specificity=function e(t){let s=t;if("string"==typeof s&&(s=h(s,{recursive:!0})),!s)return[];if("list"===s.type&&"list"in s){let t=10;const n=s.list.map((n=>{const s=e(n);return t=Math.max(t,...e(n)),s})),o=n.map((e=>m(e,t)));return n[o.indexOf(Math.max(...o))]}const o=[0,0,0];for(const[t]of f(s))switch(t.type){case"id":o[0]++;break;case"class":case"attribute":o[1]++;break;case"pseudo-element":case"type":o[2]++;break;case"pseudo-class":if("where"===t.name)break;if(!n.has(t.name)||!t.subtree){o[1]++;break}e(t.subtree).forEach(((e,t)=>o[t]+=e)),"nth-child"!==t.name&&"nth-last-child"!==t.name||o[1]++}return o},exports.specificityToNumber=m,exports.stringify=function(e){let t;return t=Array.isArray(e)?e:[...f(e)].map((([e])=>e)),t.map((e=>e.content)).join("")},exports.tokenize=u,exports.tokenizeBy=i,exports.walk=function(e,t,n){if(e)for(const[s,o]of f(e,n))t(s,o)};
