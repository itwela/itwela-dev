// src/style.ts
import { parse as parseLss } from "@lottiefiles/lottie-style-sheets";
import { colord as colord2, extend as extend2 } from "colord";
import namesPlugin2 from "colord/plugins/names";
import * as parsel from "parsel-js";
import { parse as parseValue } from "postcss-values-parser";
import { EXIT, visit as visit2, CONTINUE } from "unist-util-visit";

// src/gradient.ts
import { colord, extend } from "colord";
import namesPlugin from "colord/plugins/names";
import { parse } from "gradient-parser";
import { visit } from "unist-util-visit";
extend([namesPlugin]);
var isLinearGradient = (value) => {
  try {
    if (!value.startsWith("linear-gradient"))
      return false;
    const nodes = parse(value);
    if (nodes.length === 0)
      return false;
    const gradientNode = nodes[0];
    if (gradientNode?.type !== "linear-gradient")
      return false;
    return true;
  } catch (err) {
    return false;
  }
};
var isRadialGradient = (value) => {
  try {
    if (!value.startsWith("radial-gradient"))
      return false;
    const nodes = parse(value);
    if (nodes.length === 0)
      return false;
    const gradientNode = nodes[0];
    if (gradientNode?.type !== "radial-gradient")
      return false;
    return true;
  } catch (err) {
    return false;
  }
};
var normalizeGradient = (value) => {
  const lottieGradient = [];
  const alphaArray = [];
  if (!(isLinearGradient(value) || isRadialGradient(value)))
    return [];
  const nodes = parse(value);
  const gradient = nodes[0];
  gradient?.colorStops.forEach((colorStop, index) => {
    const rgb = [];
    let alpha = 0;
    if (colorStop.type === "hex" || colorStop.type === "literal") {
      const color = colord(colorStop.value);
      rgb.push(parseFloat((color.rgba.r / 255).toFixed(2)), parseFloat((color.rgba.g / 255).toFixed(2)), parseFloat((color.rgba.b / 255).toFixed(2)));
      alpha = color.rgba.a;
    } else if (["rgb", "rgba"].includes(colorStop.type)) {
      const color = colord({
        r: Number(colorStop.value[0]),
        g: Number(colorStop.value[1]),
        b: Number(colorStop.value[2]),
        a: colorStop.value[3] ? Number(colorStop.value[3]) : 1
      });
      rgb.push(parseFloat((color.rgba.r / 255).toFixed(2)), parseFloat((color.rgba.g / 255).toFixed(2)), parseFloat((color.rgba.b / 255).toFixed(2)));
      alpha = color.rgba.a;
    }
    let position = parseFloat((index / (gradient.colorStops.length - 1 || 1)).toFixed(2));
    if (colorStop.length?.value && Number(colorStop.length.value) > 0) {
      position = parseFloat((Number(colorStop.length.value) / 100).toFixed(2));
    }
    lottieGradient.push(position, ...rgb);
    alphaArray.push(position, alpha);
  });
  lottieGradient.push(...alphaArray);
  return lottieGradient;
};
var applyGradient = (node, gradient, gradientType) => {
  if (!["shape-gradient-fill", "shape-gradient-stroke"].includes(node.title))
    return;
  const count = gradient.length / 6;
  visit(node, "attribute", (attr) => {
    if (attr.title === "gradient-type" && attr.children[0]) {
      attr.children[0].value = gradientType === "linear" ? 1 : 2;
    } else if (attr.title === "count" && attr.children[0]) {
      attr.children[0].value = count;
    }
  });
  visit(node, "collection", (collection) => {
    if (collection.title === "static-values" && typeof collection.key === "object" && collection.key.value === "k" && collection.children[0]) {
      const childNode = collection.children[0];
      childNode.children = gradient.map((value) => ({
        type: "primitive",
        valueType: "number",
        value
      }));
    }
  });
};

// src/style.ts
extend2([namesPlugin2]);
var findNodesByAttribute = (nodeOrList, value, type, isOwnAttribute = false) => {
  const result = /* @__PURE__ */ new Set();
  const list = Array.isArray(nodeOrList) ? nodeOrList : [nodeOrList];
  for (const node of list) {
    visit2(node, "attribute", (attr, _, parent) => {
      if (attr.title === type && attr.children[0]?.value === value && parent && parent.type !== "root") {
        if (isOwnAttribute) {
          if (parent === node) {
            result.add(parent);
          }
        } else {
          result.add(parent);
        }
      }
    });
  }
  return Array.from(result);
};
var querySelectorAll = (root, selectors) => {
  const matchedNodes = [];
  for (const selector of selectors) {
    let result = [];
    const ast = parsel.parse(selector);
    parsel.walk(ast, (node, parent) => {
      const roots = result.length > 0 ? result : root;
      if (node.type === "id") {
        const lastNodes = findNodesByAttribute(roots, node.name, "layer-xml-id", parent?.type === "compound");
        result = lastNodes;
      } else if (node.type === "class") {
        const lastNodes = findNodesByAttribute(roots, node.name, "css-class", parent?.type === "compound");
        result = lastNodes;
      } else if (node.type === "type") {
        let value = "";
        let type = null;
        if (node.name === "FillShape") {
          type = "shape-type";
          value = "fl";
        } else if (node.name === "StrokeShape") {
          type = "shape-type";
          value = "st";
        } else if (node.name === "GradientFillShape") {
          type = "shape-type";
          value = "gf";
        } else if (node.name === "GradientStrokeShape") {
          type = "shape-type";
          value = "gs";
        } else if (node.name === "ShapeLayer") {
          type = "layer-type";
          value = 4;
        } else if (node.name === "SolidColorLayer") {
          type = "layer-type";
          value = 1;
        } else if (node.name === "ImageLayer") {
          type = "layer-type";
          value = 2;
        }
        if (type && value) {
          const lastNodes = findNodesByAttribute(roots, value, type);
          result = lastNodes;
        }
      } else if (node.type === "attribute") {
        let type = null;
        let value = node.value;
        if (node.name === "id") {
          type = "layer-xml-id";
        } else if (node.name === "class") {
          type = "css-class";
        } else if (node.name === "name") {
          type = "name";
        } else if (node.name === "shape-type") {
          type = "shape-type";
        } else if (node.name === "layer-type") {
          type = "layer-type";
          value = Number(node.value);
        }
        if (type && value && ["number", "string"].includes(typeof value)) {
          const lastNodes = findNodesByAttribute(roots, value, type, parent?.type === "compound");
          result = lastNodes;
        }
      }
    });
    matchedNodes.push(...result);
  }
  return Array.from(new Set(matchedNodes));
};
var isColorProperty = (prop) => {
  return prop.includes("-color");
};
var isValidFillRule = (value) => {
  return value === "nonzero" || value === "evenodd";
};
var normalizeOpacity = (value) => {
  if (value.endsWith("%")) {
    return parseFloat(value);
  }
  return parseFloat(value) * 100;
};
var normalizeFillRule = (value) => {
  if (value === "nonzero") {
    return 1;
  }
  return 2;
};
var isValidUrl = (value) => {
  try {
    new URL(value);
  } catch (_) {
    return false;
  }
  return true;
};
var getSrcUrl = (value) => {
  const root = parseValue(value);
  const nodes = root.nodes;
  if (nodes.length === 1) {
    const node = nodes[0];
    if (node && node.type === "func" && node.name === "url") {
      const nestedNodes = node.nodes;
      if (nestedNodes.length === 1) {
        const nestedNode = nestedNodes[0];
        if (nestedNode && nestedNode.type === "quoted") {
          const content = nestedNode.contents;
          return content;
        }
      }
    }
  }
  return "";
};
var normalizeStyles = (declarations) => {
  const styles = {};
  for (const declaration of declarations) {
    if (isColorProperty(declaration.property) && colord2(declaration.value).isValid()) {
      const rgbaColor = colord2(declaration.value).rgba;
      const value = [rgbaColor.r / 255, rgbaColor.g / 255, rgbaColor.b / 255, rgbaColor.a];
      switch (declaration.property) {
        case "fill-color":
          styles["fill-color"] = value;
          break;
        case "stroke-color":
          styles["stroke-color"] = value;
          break;
        default:
          break;
      }
    } else if (isColorProperty(declaration.property) && isLinearGradient(declaration.value)) {
      const value = normalizeGradient(declaration.value);
      switch (declaration.property) {
        case "fill-color":
          styles["linear-gradient-fill-color"] = value;
          break;
        case "stroke-color":
          styles["linear-gradient-stroke-color"] = value;
          break;
        default:
          break;
      }
    } else if (isColorProperty(declaration.property) && isRadialGradient(declaration.value)) {
      const value = normalizeGradient(declaration.value);
      switch (declaration.property) {
        case "fill-color":
          styles["radial-gradient-fill-color"] = value;
          break;
        case "stroke-color":
          styles["radial-gradient-stroke-color"] = value;
          break;
        default:
          break;
      }
    } else if (declaration.property === "stroke-width") {
      styles["stroke-width"] = Number(declaration.value);
    } else if (declaration.property === "fill-rule" && isValidFillRule(declaration.value)) {
      styles["fill-rule"] = normalizeFillRule(declaration.value);
    } else if (declaration.property === "opacity") {
      const opacity = normalizeOpacity(declaration.value);
      if (Number.isNaN(opacity)) {
        continue;
      }
      if (opacity < 0) {
        styles["opacity"] = 0;
      } else if (opacity > 100) {
        styles["opacity"] = 100;
      } else {
        styles["opacity"] = opacity;
      }
    } else if (declaration.property === "visibility") {
      styles["hidden"] = declaration.value === "hidden";
    } else if (declaration.property === "src") {
      const url = getSrcUrl(declaration.value);
      if (isValidUrl(url)) {
        styles["src"] = url;
      }
    }
  }
  return styles;
};
var apply = (targetNode, styles, root) => {
  for (const prop in styles) {
    switch (prop) {
      case "fill-color":
        const rgbaArray = styles[prop];
        if (targetNode.title === "shape-fill") {
          if (Array.isArray(rgbaArray)) {
            visit2(targetNode, "array", (node) => {
              const title = node.title;
              if (title === "color-rgba-children" && node.children.length === 4) {
                node.children = node.children.map((child, index) => ({
                  ...child,
                  value: rgbaArray[index]
                }));
                return EXIT;
              }
              return CONTINUE;
            });
          }
        } else if (targetNode.title === "layer-solid-color") {
          visit2(targetNode, "attribute", (attr) => {
            if (attr.title === "hex-color" && attr.children[0]?.value && rgbaArray?.length === 4) {
              const hex = colord2({
                r: rgbaArray[0] * 255,
                g: rgbaArray[1] * 255,
                b: rgbaArray[2] * 255,
                a: rgbaArray[3]
              }).toHex();
              attr.children[0].value = hex;
            }
          });
        }
        break;
      case "stroke-color":
        if (targetNode.title === "shape-stroke") {
          const rgbaArray2 = styles[prop];
          if (Array.isArray(rgbaArray2)) {
            visit2(targetNode, "array", (node) => {
              const title = node.title;
              if (title === "static-values-children" && node.children.length === 4) {
                node.children = node.children.map((child, index) => ({
                  ...child,
                  value: rgbaArray2[index]
                }));
                return EXIT;
              }
              return CONTINUE;
            });
          }
        }
        break;
      case "stroke-width":
        if (targetNode.title === "shape-stroke" || targetNode.title === "shape-gradient-stroke") {
          visit2(targetNode, "element", (node) => {
            if (node.title === "stroke-width") {
              visit2(node, "attribute", (attr, _, parent) => {
                if (attr.title === "static-value" && attr.children[0]?.value && attr.children[0].valueType === "number" && parent?.title === "animated-value-static") {
                  attr.children[0].value = styles[prop];
                }
              });
            }
          });
        }
        break;
      case "fill-rule":
        if (["shape-fill", "shape-gradient-fill"].includes(targetNode.title)) {
          visit2(targetNode, "attribute", (attr) => {
            if (attr.title === "fill-rule-value" && attr.children[0]?.value) {
              attr.children[0].value = styles[prop];
            }
          });
        }
        break;
      case "opacity":
        if (["shape-stroke", "shape-fill", "shape-gradient-fill", "shape-gradient-stroke"].includes(targetNode.title)) {
          visit2(targetNode, "element", (node) => {
            if (["stroke-opacity", "opacity"].includes(node.title)) {
              visit2(node, "attribute", (attr, _, parent) => {
                if (attr.title === "static-value" && attr.children[0]?.value && attr.children[0].valueType === "number" && parent?.title === "animated-value-static") {
                  attr.children[0].value = styles[prop];
                }
              });
            }
          });
        }
        break;
      case "hidden":
        if (targetNode.title.includes("shape") || targetNode.title.includes("layer")) {
          visit2(targetNode, "attribute", (attr) => {
            if (attr.title === "hidden" && attr.children[0]) {
              attr.children[0].value = styles[prop];
            }
          });
        }
        break;
      case "linear-gradient-fill-color":
      case "linear-gradient-stroke-color":
        applyGradient(targetNode, styles[prop], "linear");
        break;
      case "radial-gradient-fill-color":
      case "radial-gradient-stroke-color":
        applyGradient(targetNode, styles[prop], "radial");
        break;
      case "src":
        if (targetNode.title === "layer-image") {
          const attr = targetNode.children.find((node) => node.title === "image-id");
          if (attr?.type === "attribute") {
            const imgId = attr.children[0]?.value;
            visit2(root, "object", (object) => {
              if (object.title === "asset-image") {
                const isSameImage = object.children.some((node) => node.title === "id" && node.children[0]?.type === "primitive" && node.children[0].value === imgId);
                if (isSameImage) {
                  visit2(object, "attribute", (attrNode) => {
                    if (attrNode.title === "embedded" && attrNode.children[0]) {
                      attrNode.children[0].value = 0;
                    } else if (attrNode.title === "path" && attrNode.children[0]) {
                      attrNode.children[0].value = "";
                    } else if (attrNode.title === "filename" && attrNode.children[0]) {
                      attrNode.children[0].value = styles[prop];
                    }
                  });
                }
              }
            });
          }
        }
        break;
      default:
        break;
    }
  }
};
var relottieStyle = (options = { lss: "" }) => {
  const transformer = async (last) => {
    const lssast = parseLss(options.lss);
    visit2(lssast, "rule", (node) => {
      const lastNodes = querySelectorAll(last, node.selectors);
      const styles = normalizeStyles(node.children);
      for (const lastNode of lastNodes) {
        apply(lastNode, styles, last);
      }
    });
  };
  return transformer;
};
var style_default = relottieStyle;
export {
  style_default as default
};
//# sourceMappingURL=index.js.map