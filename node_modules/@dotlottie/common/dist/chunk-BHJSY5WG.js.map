{"version":3,"sources":["../../../node_modules/.pnpm/@preact+signals-core@1.4.0/node_modules/@preact/signals-core/src/index.ts","../src/store.ts"],"names":["cycleDetected","Error","endBatch","batchDepth","error","hasError","batchedEffect","effect","batchIteration","next","_nextBatchedEffect","_flags","needsToRecompute","_callback","err","evalContext","globalVersion","addDependency","signal","node","_node","_target","_version","_source","_prevSource","_sources","_nextSource","_prevTarget","_nextTarget","_rollbackNode","_subscribe","Signal","value","this","_value","_targets","prototype","_refresh","_unsubscribe","prev","subscribe","fn","flag","valueOf","toString","toJSON","peek","Object","defineProperty","get","set","Computed","mutationDetected","_notify","target","prepareSources","rollbackNode","cleanupSources","head","compute","call","undefined","_compute","_globalVersion","prevContext","OUTDATED","cleanupEffect","cleanup","_cleanup","disposeEffect","endEffect","Effect","finish","_start","bind","_dispose","Store","initialState","d","state","callback","val"],"mappings":"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","sourcesContent":["function cycleDetected(): never {\n\tthrow new Error(\"Cycle detected\");\n}\nfunction mutationDetected(): never {\n\tthrow new Error(\"Computed cannot have side-effects\");\n}\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t// Use the special value -1 to mark potentially unused but recyclable nodes.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\nfunction batch<T>(callback: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn callback();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn callback();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\nlet untrackedDepth = 0;\n\nfunction untracked<T>(callback: () => T): T {\n\tif (untrackedDepth > 0) {\n\t\treturn callback();\n\t}\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\tuntrackedDepth++;\n\ttry {\n\t\treturn callback();\n\t} finally {\n\t\tuntrackedDepth--;\n\t\tevalContext = prevContext;\n\t}\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t/**\n\t\t * `signal` is a new dependency. Create a new dependency node, and set it\n\t\t * as the tail of the current context's dependency list. e.g:\n\t\t *\n\t\t * { A <-> B       }\n\t\t *         ↑     ↑\n\t\t *        tail  node (new)\n\t\t *               ↓\n\t\t * { A <-> B <-> C }\n\t\t *               ↑\n\t\t *              tail (evalContext._sources)\n\t\t */\n\t\tnode = {\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: evalContext._sources,\n\t\t\t_nextSource: undefined,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\n\t\tif (evalContext._sources !== undefined) {\n\t\t\tevalContext._sources._nextSource = node;\n\t\t}\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._version === -1) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse it.\n\t\tnode._version = 0;\n\n\t\t/**\n\t\t * If `node` is not already the current tail of the dependency list (i.e.\n\t\t * there is a next node in the list), then make the `node` the new tail. e.g:\n\t\t *\n\t\t * { A <-> B <-> C <-> D }\n\t\t *         ↑           ↑\n\t\t *        node   ┌─── tail (evalContext._sources)\n\t\t *         └─────│─────┐\n\t\t *               ↓     ↓\n\t\t * { A <-> C <-> D <-> B }\n\t\t *                     ↑\n\t\t *                    tail (evalContext._sources)\n\t\t */\n\t\tif (node._nextSource !== undefined) {\n\t\t\tnode._nextSource._prevSource = node._prevSource;\n\n\t\t\tif (node._prevSource !== undefined) {\n\t\t\t\tnode._prevSource._nextSource = node._nextSource;\n\t\t\t}\n\n\t\t\tnode._prevSource = evalContext._sources;\n\t\t\tnode._nextSource = undefined;\n\n\t\t\tevalContext._sources!._nextSource = node;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n// @ts-ignore internal Signal is viewed as a function\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/**\n\t * @internal\n\t * Version numbers should always be >= 0, because the special value -1 is used\n\t * by Nodes to signify potentially unused but recyclable nodes.\n\t */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\ttoJSON(): T;\n\n\tpeek(): T;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\n/** @internal */\n// @ts-ignore internal Signal is viewed as function\nfunction Signal(this: Signal, value?: unknown) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n}\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tif (this._targets !== node && node._prevTarget === undefined) {\n\t\tnode._nextTarget = this._targets;\n\t\tif (this._targets !== undefined) {\n\t\t\tthis._targets._prevTarget = node;\n\t\t}\n\t\tthis._targets = node;\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the signal has any subscribers to begin with.\n\tif (this._targets !== undefined) {\n\t\tconst prev = node._prevTarget;\n\t\tconst next = node._nextTarget;\n\t\tif (prev !== undefined) {\n\t\t\tprev._nextTarget = next;\n\t\t\tnode._prevTarget = undefined;\n\t\t}\n\t\tif (next !== undefined) {\n\t\t\tnext._prevTarget = prev;\n\t\t\tnode._nextTarget = undefined;\n\t\t}\n\t\tif (node === this._targets) {\n\t\t\tthis._targets = next;\n\t\t}\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\tconst signal = this;\n\treturn effect(function (this: Effect) {\n\t\tconst value = signal.value;\n\t\tconst flag = this._flags & TRACKING;\n\t\tthis._flags &= ~TRACKING;\n\t\ttry {\n\t\t\tfn(value);\n\t\t} finally {\n\t\t\tthis._flags |= flag;\n\t\t}\n\t});\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n\treturn this.value;\n};\n\nSignal.prototype.peek = function () {\n\treturn this._value;\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget() {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(this: Signal, value) {\n\t\tif (evalContext instanceof Computed) {\n\t\t\tmutationDetected();\n\t\t}\n\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tcycleDetected();\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\nfunction signal<T>(value: T): Signal<T> {\n\treturn new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n\t// Check the dependencies for changed values. The dependency list is already\n\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t// the first used dependency is re-evaluated at this point.\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\t// If there's a new version of the dependency before or after refreshing,\n\t\t// or the dependency has something blocking it from refreshing at all (e.g. a\n\t\t// dependency cycle), then we need to recompute.\n\t\tif (\n\t\t\tnode._source._version !== node._version ||\n\t\t\t!node._source._refresh() ||\n\t\t\tnode._source._version !== node._version\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t// If none of the dependencies have changed values since last recompute then\n\t// there's no need to recompute.\n\treturn false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\t/**\n\t * 1. Mark all current sources as re-usable nodes (version: -1)\n\t * 2. Set a rollback node if the current node is being used in a different context\n\t * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n\t *\n\t *    { undefined <- A <-> B <-> C -> undefined }\n\t *                   ↑           ↑\n\t *                   │           └──────┐\n\t * target._sources = A; (node is head)  │\n\t *                   ↓                  │\n\t * target._sources = C; (node is tail) ─┘\n\t */\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._version = -1;\n\n\t\tif (node._nextSource === undefined) {\n\t\t\ttarget._sources = node;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\tlet node = target._sources;\n\tlet head = undefined;\n\n\t/**\n\t * At this point 'target._sources' points to the tail of the doubly-linked list.\n\t * It contains all existing sources + new sources in order of use.\n\t * Iterate backwards until we find the head node while dropping old dependencies.\n\t */\n\twhile (node !== undefined) {\n\t\tconst prev = node._prevSource;\n\n\t\t/**\n\t\t * The node was not re-used, unsubscribe from its change notifications and remove itself\n\t\t * from the doubly-linked list. e.g:\n\t\t *\n\t\t * { A <-> B <-> C }\n\t\t *         ↓\n\t\t *    { A <-> C }\n\t\t */\n\t\tif (node._version === -1) {\n\t\t\tnode._source._unsubscribe(node);\n\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev._nextSource = node._nextSource;\n\t\t\t}\n\t\t\tif (node._nextSource !== undefined) {\n\t\t\t\tnode._nextSource._prevSource = prev;\n\t\t\t}\n\t\t} else {\n\t\t\t/**\n\t\t\t * The new head is the last node seen which wasn't removed/unsubscribed\n\t\t\t * from the doubly-linked list. e.g:\n\t\t\t *\n\t\t\t * { A <-> B <-> C }\n\t\t\t *   ↑     ↑     ↑\n\t\t\t *   │     │     └ head = node\n\t\t\t *   │     └ head = node\n\t\t\t *   └ head = node\n\t\t\t */\n\t\t\thead = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\n\t\tnode = prev;\n\t}\n\n\ttarget._sources = head;\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n\t_compute: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(compute: () => T);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\nfunction Computed(this: Computed, compute: () => unknown) {\n\tSignal.call(this, undefined);\n\n\tthis._compute = compute;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0 && !needsToRecompute(this)) {\n\t\tthis._flags &= ~RUNNING;\n\t\treturn true;\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._compute();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when the it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the computed signal has any subscribers.\n\tif (this._targets !== undefined) {\n\t\tSignal.prototype._unsubscribe.call(this, node);\n\n\t\t// Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n\t\t// This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n\t\tif (this._targets === undefined) {\n\t\t\tthis._flags &= ~TRACKING;\n\n\t\t\tfor (\n\t\t\t\tlet node = this._sources;\n\t\t\t\tnode !== undefined;\n\t\t\t\tnode = node._nextSource\n\t\t\t) {\n\t\t\t\tnode._source._unsubscribe(node);\n\t\t\t}\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nComputed.prototype.peek = function () {\n\tif (!this._refresh()) {\n\t\tcycleDetected();\n\t}\n\tif (this._flags & HAS_ERROR) {\n\t\tthrow this._value;\n\t}\n\treturn this._value;\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget() {\n\t\tif (this._flags & RUNNING) {\n\t\t\tcycleDetected();\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\ninterface ReadonlySignal<T = any> extends Signal<T> {\n\treadonly value: T;\n}\n\nfunction computed<T>(compute: () => T): ReadonlySignal<T> {\n\treturn new Computed(compute);\n}\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\teffect._flags |= DISPOSED;\n\t\t\tdisposeEffect(effect);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._compute = undefined;\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ntype EffectCleanup = () => unknown;\ndeclare class Effect {\n\t_compute?: () => unknown | EffectCleanup;\n\t_cleanup?: () => unknown;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\n\tconstructor(compute: () => unknown | EffectCleanup);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n}\n\nfunction Effect(this: Effect, compute: () => unknown | EffectCleanup) {\n\tthis._compute = compute;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (this._flags & DISPOSED) return;\n\t\tif (this._compute === undefined) return;\n\n\t\tconst cleanup = this._compute();\n\t\tif (typeof cleanup === \"function\") {\n\t\t\tthis._cleanup = cleanup as EffectCleanup;\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tcycleDetected();\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tcleanupEffect(this);\n\tprepareSources(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\nfunction effect(compute: () => unknown | EffectCleanup): () => void {\n\tconst effect = new Effect(compute);\n\ttry {\n\t\teffect._callback();\n\t} catch (err) {\n\t\teffect._dispose();\n\t\tthrow err;\n\t}\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\treturn effect._dispose.bind(effect);\n}\n\nexport {\n\tsignal,\n\tcomputed,\n\teffect,\n\tbatch,\n\tSignal,\n\ttype ReadonlySignal,\n\tuntracked,\n};\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\nimport type { Signal } from '@preact/signals-core';\nimport { signal } from '@preact/signals-core';\n\nexport class Store<T> {\n  protected _state: Signal<T>;\n\n  protected _prevState: T;\n\n  public constructor(initialState: T) {\n    this._prevState = initialState;\n    this._state = signal(initialState);\n  }\n\n  public setState(state: T): void {\n    this._prevState = this._state.value;\n    this._state.value = state;\n  }\n\n  public subscribe(callback: (value: T, prevValue: T) => void): () => void {\n    return this._state.subscribe((val) => callback(val, this._prevState));\n  }\n}\n"]}